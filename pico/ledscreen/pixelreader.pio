; Receives the pixel data from the input pins and stores it to 
; a DMA buffer. Each pixel has 12 bits that are provided on 6 input pins using
; double data rate. At the rising edge of the input clock, the higher 6 bits are
; also presented (need to delay a bit before reading), the lower 6 bits are 
; available after the falling edge of the input clock.
; 4 bits of extra padding are added to the dma stream per pixel, so every 32-bit
; word contains two pixels (first pixel in the higher bits). 
; After 320 pixels for one line are transfered, the sender continues to run the clock
; for a short time to allow for some slips and then the clock stops at the low state.
; Already during this extra clocks and alos afterwards, the data pins are either
; all '0' or all '1'. ('0' means, this was the first line of the frame). 
; After at least 1 us in low state, the next line may be transfered.

.program pixelreader
.wrap_target
    set x 0x13                 ; construct number 319 = $13F in Y
	mov isr x                  ; to make this work, need to have set direction to left
    set x 0xf
	in x 4
	mov y isr
	
resetidlecounter:
	set x 31
waitforidle:                   ; wait until clock is low for at least 1us
	jmp pin resetidlecounter
	jmp pin resetidlecounter
	jmp pin resetidlecounter
	jmp pin resetidlecounter
	jmp pin resetidlecounter
	jmp x-- waitforidle
	
	mov isr x                  ; clear shift register in preparation to read pixels

fetchpixel:
	wait 1 pin 6               ; read first half of pixel
	in null 4     [6]
	in pins 6	      
	
	wait 0 pin 6               ; read second half of pixel
	mov x x       [6]
	in pins 6     
	
	push iffull block
	jmp y-- fetchpixel

	irq nowait 0   [5]         ; notify CPU that the line is complete
	irq clear 0
.wrap
